/*All rights reserved.
 *
 * Eigen Technologies Pvt. Ltd.
 * New Delhi
 * www.eigen.in
 *
 * This source code is provided to SensenutsTM  users for
 * research purpose only. No portion of this source code
 * may be used as the basis of development of any similar
 * kind of product.
 *
 */

#include <jendefs.h>
#include <AppHardwareApi.h>
#include <AppQueueApi.h>

#include "clock.h"  //provides clock related functionality
#include "node.h"
#include "task.h"

/*******************************Do not modify above this line********************************/

//add header file for communication with PC
#include "pcInterface.h"

//add header file for mac layer APIs
#include "mac.h"

//add header file for routing
#include "routing.h"

#include "phy.h"
uint16 nodeId;
/*user defined packet type should always be greater than 0x23 as routing protocols
define their packet types below this value.*/
#define USER_PACKET_TYPE 0x30
#define USER_PACKET_TYPE1 0x31
#define READ_DATA_IN_PC_BUFFER 0
#define time 100
//to read from uart from three things will be required
//**************************************************************
int curPcPktCount=0;

//variable to store data coming from pc
uint8 rxBuffer[127];
//task type to be used in this case
#define READ_DATA_IN_PC_BUFFER 1
//**************************************************************

//*******************************************************************************
//Program execution starts from this function. It is like main function
//*******************************************************************************
void startNode()
{
//initialize port to communicate with pc
	sendToPcInit();
	receiveFrmPcInit();

//initialize mac layer
	macInit();
	
	eAppApiPlmeSet(PHY_PIB_ATTR_TX_POWER,0);

	//addTask(USER,1,1*SECOND);
}

uint8 count1=0;
//*******************************************************************************
//              All the tasks added by user expire in this function
//*******************************************************************************
void userTaskHandler(uint8 taskType)
{
	int i;
	uint16 nodeIdm = getNodeId();
	
	if (taskType==READ_DATA_IN_PC_BUFFER)
	{
		if(rxBuffer[0]==0x50)			//0x51 means the packet is being generated by special command window
										//packet format: msgtype[0x50],length of data,data payload,checksum
										//checksum = xor of all bytes before checksum
		{
			//check if the packet is getting received properly or not by comparing the checksum sent by gui with self calculated checksum

			
			uint8 checksum=0;
			
			for (i=0;i<curPcPktCount-1;i++)
			{
				checksum^=rxBuffer[i];
			}

			if (checksum==rxBuffer[curPcPktCount-1])
			{
				//packet is received properly

				//let us get all the data and send it back to reply receive window of special command window as it is. 
				//while replying no need to send checksum

				//create the packet to send on network

				//debug(&rxBuffer,curPcPktCount);
				uint8 packet[127];

				packet[0]=USER_PACKET_TYPE1;	//packet type info
				packet[1]=rxBuffer[2];
				packet[2]=nodeIdm>>8;		//source address
				packet[3]=nodeIdm;

				uint16 destAddr= rxBuffer[3];
				destAddr=destAddr<<8;
				destAddr=destAddr|rxBuffer[4];

				//send the packet to  routing protocol for further processing
				routingSendData(packet, 4, nodeId);
			}
		}
	}
	//reset the curPcPktCount 
	curPcPktCount=0;
}

//*******************************************************************************
//When a data packet from network is received, this function gets called from OS.
//*******************************************************************************
void userReceiveDataPacket(uint8* payload,uint8 length,uint16 prevAddr,uint8 linkQuality)
{
	uint16 adc1;
		uint16 adc2;
		uint16 adc3;
		uint16 adc4;
		if (payload[0]==USER_PACKET_TYPE)
		{
			adc1=payload[1];
			adc1=adc1<<8;
			adc1=adc1 | payload[2];
			adc2=payload[3];
			adc2=adc2<<8;
			adc2=adc2 | payload[4];
			adc3=payload[5];
			adc3=adc3<<8;
			adc3=adc3 | payload[6];
			adc4=payload[7];
			adc4=adc4<<8;
			adc4=adc4 | payload[8];
			debug(linkQuality, sizeof(uint8));
			//update info in database present in PC
			UpdateSLbADC(prevAddr,adc1,adc2,adc3,adc4);
			nodeId = prevAddr;
		}
/*
	uint8 tmp;
	uint16 light;

	if (payload[0]==USER_PACKET_TYPE)
	{
		tmp=payload[1];
		light=payload[2];
		light=light<<8;
		light=light | payload[3];
		nodeId=payload[4];
		nodeId=nodeId<<8;
		nodeId=nodeId|payload[5];
		ledOn();
//update info in database present in PC
		updateSTLdb(nodeId,light,tmp);
	}

	//debug(payload,length);
/*
	uint8 packetToPC[100];
	int i,j;

	packetToPC[0]=0x48;
	// node id of destination which is pan coordinator in this case
	packetToPC[1]=0x00;
	packetToPC[2]=0x00;

	for(i=length-1,j=3;i>4;i=i-2,j=j+2)
	{
		packetToPC[j]=payload[i-1];
		packetToPC[j+1]=payload[i];
	}

	updateGendb(packetToPC,j);*/
}

//*******************************************************************************
//                  A dio event is received in this function. 
//*******************************************************************************
void userCriticalTaskHandler(uint8 critTaskType)
{
	
}

//#########################################################################################################################################
//														A very special function
//#########################################################################################################################################

//*******************************************************************************
//  this function gets called if receive from pc is enabled and a byte 
//  is received from pc. This is getting called from interrupt handler
//  unlike other functions which were all scheduled by OS. This being 
//  an interrupt handler, must be having least possible statements so 
//  that the device comes back to normal operation out of interrupt quickly.
//*******************************************************************************
void pcInterruptHandler()
{
	if (curPcPktCount==0)
		addTask(USER,READ_DATA_IN_PC_BUFFER,5*MILLI_SECOND);		//based on the baud rate which is 115200 bits/sec, in 5 secs 
																	//the device is capable of receiving more than 50 bytes

	//save current byte in packet
	rxBuffer[curPcPktCount]=readByteFromPc();
	
	//update buffer count
	curPcPktCount++;
}
